{"version":3,"file":"slidemanager.js","sources":["../src/raf-interval.js","../src/slidemanager.js"],"sourcesContent":["const queue = []\r\nlet id = -1\r\nlet ticking = false\r\nlet tickId = null\r\n\r\nexport const setRafInterval = (fn, interval) => {\r\n  id++\r\n\r\n  queue.push({\r\n    id,\r\n    fn,\r\n    interval,\r\n    lastTime: performance.now()\r\n  })\r\n\r\n  if (!ticking) {\r\n    const tick = () => {\r\n      tickId = requestAnimationFrame(tick)\r\n\r\n      queue.forEach((item) => {\r\n        if (item.interval < 17 || performance.now() - item.lastTime >= item.interval) {\r\n          item.fn()\r\n          item.lastTime = performance.now()\r\n        }\r\n      })\r\n    }\r\n\r\n    ticking = true\r\n\r\n    tick()\r\n  }\r\n\r\n  return id\r\n}\r\n\r\nexport const clearRafInterval = (rafID) => {\r\n  for (let i = 0; i < queue.length; i++) {\r\n    if (rafID === queue[i].id) {\r\n      queue.splice(i, 1)\r\n\r\n      break\r\n    }\r\n  }\r\n\r\n  if (queue.length === 0) {\r\n    cancelAnimationFrame(tickId)\r\n\r\n    ticking = false\r\n  }\r\n}\r\n","import { setRafInterval, clearRafInterval } from './raf-interval'\r\n\r\n/**\r\n * Creates a slidemanager instance.\r\n *\r\n * @class\r\n */\r\nexport default class Slidemanager {\r\n\r\n  /**\r\n   * Creates a slidemanager instance.\r\n   *\r\n   * @param {Object} opt - An object with the desired parameters.\r\n   * @param {Element} opt.el - A DOM element. If given, the number of elements will depends on its children count.\r\n   * @param {Number} opt.length - The number of elements to slide through (if not given, it will be the `el` children count).\r\n   * @param {Function} opt.callback - The callback method in which you will be able to animate to a new slide.\r\n   * @param {Boolean} [opt.loop=false] - Whether the slider should loop or not.\r\n   * @param {Boolean} [opt.random=false] - Whether the slider should go to a random index instead of previous and next.\r\n   * @param {Boolean} [opt.vertical=false] - If enabled, the swipe and mouseSwipe gestures will check for a vertical movement (`swipe` or `mouseSwipe` must be set to true for this parameter to take effect).\r\n   * @param {Boolean} [opt.auto=false] - If enabled, the slider will automatically go to a new slide after a while.\r\n   * @param {Number} [opt.interval=5] - The number of seconds to wait between two slides (only works if `auto` is set to `true`).\r\n   * @param {Boolean} [opt.init=true] - If set to `false`, the slidemanager will not initiate its events right away. You will have to call `.init()` to start listening for events and/or launching set timer if `auto` is enabled.\r\n   * @param {Boolean} [opt.swipe=true] - By default, the touch swipe movement is enabled.\r\n   * @param {Boolean} [opt.mouseSwipe=false] - By default, the mouse swipe movement is disabled.\r\n   * @param {Number} [opt.startAt=0] - The starting index of the slider.\r\n   * @param {Number} [opt.threshold=60] - The amount of pixel to swipe before starting a navigation to a new slide (applies to both touch swipe and mouse swipe).\r\n   *\r\n   * @returns {void}\r\n   * @constructor\r\n   */\r\n  constructor(opt = {}) {\r\n    if (!opt.callback) {\r\n      console.warn('Slidemanager: Missing `callback` property in constructor.')\r\n\r\n      return\r\n    }\r\n\r\n    if (this.max === -1) {\r\n      console.warn('Slidemanager: Missing `el` or `length` property in constructor.')\r\n\r\n      return\r\n    }\r\n\r\n    this.bindMethods()\r\n\r\n    const defaults = {\r\n      el: null,\r\n      loop: false,\r\n      random: false,\r\n      vertical: false,\r\n      callback: this.done,\r\n      auto: false,\r\n      interval: 5,\r\n      init: true,\r\n      swipe: true,\r\n      mouseSwipe: false,\r\n      startAt: 0,\r\n      threshold: 60\r\n    }\r\n\r\n    this.options = Object.assign(defaults, opt)\r\n\r\n    this.el = opt.el\r\n    this.changing = false\r\n    this.max = opt.length > 0 ? opt.length : opt.el && opt.el.children ? opt.el.children.length : -1\r\n    this.index = !isNaN(opt.startAt) && opt.startAt !== defaults.startAt ? Math.max(0, Math.min(opt.startAt, this.max)) : 0\r\n\r\n    this.intervalID = null\r\n\r\n    this.touch = {\r\n      startX: 0,\r\n      startY: 0,\r\n      endX: 0,\r\n      endY: 0\r\n    }\r\n\r\n    this.diagonalMax = 125\r\n\r\n    if (this.options.init) this.init()\r\n  }\r\n\r\n  /**\r\n   * Binds the methods to this instance.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  bindMethods() {\r\n    this.intervalFn = this.intervalFn.bind(this)\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.touchStart = this.touchStart.bind(this)\r\n    this.touchEnd = this.touchEnd.bind(this)\r\n    this.done = this.done.bind(this)\r\n  }\r\n\r\n  // Public functions\r\n\r\n  /**\r\n   * Initiates the swipe events if enabled.\r\n   * Also starts the auto timer if enabled.\r\n   *\r\n   * This method is automatically called by constructor by default.\r\n   *\r\n   * @public\r\n   * @returns {Slidemanager} - This instance.\r\n   */\r\n  init() {\r\n    if (this.max === 0) return null\r\n\r\n    if (this.options.auto) this.start()\r\n    if (this.options.swipe) this.events()\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Destroys the slidemanager.\r\n   *\r\n   * Removes the eventlisteners and kills the auto timer.\r\n   *\r\n   * @public\r\n   * @returns {Slidemanager} - This instance.\r\n   */\r\n  destroy() {\r\n    if (this.max === 0) return null\r\n\r\n    this.changing = false\r\n\r\n    if (this.options.swipe && this.el) {\r\n      if (this.options.mouseSwipe) {\r\n        this.el.removeEventListener('mousedown', this.touchStart)\r\n        this.el.removeEventListener('mouseup', this.touchEnd)\r\n      }\r\n\r\n      this.el.removeEventListener('touchstart', this.touchStart)\r\n      this.el.removeEventListener('touchend', this.touchEnd)\r\n    }\r\n\r\n    if (this.options.auto) this.stop()\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Returns the current slider index.\r\n   *\r\n   * @public\r\n   * @returns {Number} - The current index.\r\n   */\r\n  getIndex() {\r\n    return this.index\r\n  }\r\n\r\n  /**\r\n   * Goes to the previous element in the slider.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  prev() {\r\n    this.goTo(this.index - 1)\r\n  }\r\n\r\n  /**\r\n   * Goes to the next element in the slider.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  next() {\r\n    this.goTo(this.index + 1)\r\n  }\r\n\r\n  /**\r\n   * Goes to a given element in the slider.\r\n   *\r\n   * @param {Number} index - The target index you want to move to.\r\n   * @param {*} data - Any data you want to retreive when the `callback` will be called.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  goTo(index, data) {\r\n    if (index === this.index || this.isChanging()) return\r\n\r\n    const checkedIndex = this.checkLoop(index)\r\n\r\n    if (checkedIndex === this.index) {\r\n      this.changing = false\r\n\r\n      return\r\n    }\r\n\r\n    const event = this.createEvent(checkedIndex, data)\r\n\r\n    if (this.options.auto) this.stop()\r\n\r\n    this.index = checkedIndex\r\n    this.options.callback(event)\r\n  }\r\n\r\n  /**\r\n   * Starts the `auto` timer.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  start() {\r\n    if (!this.options.auto || this.isChanging()) return\r\n\r\n    if (this.intervalID) this.stop()\r\n\r\n    this.intervalID = setRafInterval(this.intervalFn, this.options.interval * 1000)\r\n  }\r\n\r\n  /**\r\n   * Stops the `auto` timer.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  stop() {\r\n    if (!this.options.auto || this.isChanging()) return\r\n\r\n    clearRafInterval(this.intervalID)\r\n\r\n    this.intervalID = null\r\n  }\r\n\r\n  /**\r\n   * Call this method when your animation between slides is over.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  done() {\r\n    this.changing = false\r\n\r\n    if (this.options.auto) this.start()\r\n  }\r\n\r\n  // Private functions\r\n\r\n  /**\r\n   * Initiates the events (touch swipe and mouse swipe).\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  events() {\r\n    if (!this.el) return\r\n\r\n    if (this.options.mouseSwipe) {\r\n      this.el.addEventListener('mousedown', this.touchStart)\r\n      this.el.addEventListener('mouseup', this.touchEnd)\r\n    }\r\n\r\n    this.el.addEventListener('touchstart', this.touchStart)\r\n    this.el.addEventListener('touchend', this.touchEnd)\r\n  }\r\n\r\n  /**\r\n   * The touchstart event callback.\r\n   *\r\n   * @private\r\n   * @param {TouchEvent} event - The TouchEvent.\r\n   */\r\n  touchStart(event) {\r\n    this.touch.startX = event.type === 'touchstart' ? event.touches[0].screenX : event.screenX\r\n    this.touch.startY = event.type === 'touchstart' ? event.touches[0].screenY : event.screenY\r\n  }\r\n\r\n  /**\r\n   * The touchend event callback.\r\n   *\r\n   * @private\r\n   * @param {TouchEvent} event - The TouchEvent.\r\n   */\r\n  touchEnd(event) {\r\n    this.touch.endX = event.type === 'touchend' ? event.changedTouches[0].screenX : event.screenX\r\n    this.touch.endY = event.type === 'touchend' ? event.changedTouches[0].screenY : event.screenY\r\n\r\n    this.handleSwipe()\r\n  }\r\n\r\n  /**\r\n   * Checks if the touch gesture is going to X axis or not.\r\n   *\r\n   * @private\r\n   * @returns {Boolean} - `true` if the gesture is going to X axis, `false` if not going to X axis.\r\n   */\r\n  isGoingToX() {\r\n    return this.touch.endX < this.touch.startX && this.touch.startX - this.touch.endX <= this.diagonalMax || this.touch.endX > this.touch.startX && this.touch.endX - this.touch.startX <= this.diagonalMax\r\n  }\r\n\r\n  /**\r\n   * Checks if the touch gesture is going to Y axis or not.\r\n   *\r\n   * @private\r\n   * @returns {Boolean} - `true` if the gesture is going to Y axis, `false` if not going to Y axis.\r\n   */\r\n  isGoingToY() {\r\n    return this.touch.endY < this.touch.startY && this.touch.startY - this.touch.endY <= this.diagonalMax || this.touch.endY > this.touch.startY && this.touch.endY - this.touch.startY <= this.diagonalMax\r\n  }\r\n\r\n  /**\r\n   * Manages the touchend event calculation to define if a slide needs to be made or not.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  handleSwipe() {\r\n    if (this.changing) return\r\n\r\n    if (this.options.vertical) {\r\n      if (this.touch.endY < this.touch.startY && this.touch.startY - this.touch.endY >= this.options.threshold) {\r\n        if (this.isGoingToX()) this.callback(-1)\r\n      }\r\n      if (this.touch.endY > this.touch.startY && this.touch.endY - this.touch.startY >= this.options.threshold) {\r\n        if (this.isGoingToX()) this.callback(1)\r\n      }\r\n    } else {\r\n      if (this.touch.endX < this.touch.startX && this.touch.startX - this.touch.endX >= this.options.threshold) {\r\n        if (this.isGoingToY()) this.callback(-1)\r\n      }\r\n      if (this.touch.endX > this.touch.startX && this.touch.endX - this.touch.startX >= this.options.threshold) {\r\n        if (this.isGoingToY()) this.callback(1)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The internal interval function called when the `auto` timer is over.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  intervalFn() {\r\n    if (this.changing) return\r\n\r\n    this.callback(-1)\r\n  }\r\n\r\n  /**\r\n   * Checks if the slider is animating.\r\n   *\r\n   * @returns {Boolean} - `true` if the slider is currently waiting for an animation to be other, `false` otherwise.\r\n   */\r\n  isChanging() {\r\n    if (this.changing) return true\r\n\r\n    this.changing = true\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Returns a new index from a given direction.\r\n   *\r\n   * @param {Number} delta - The direction of the index change.\r\n   *\r\n   * @private\r\n   * @returns {Number} - The new index.\r\n   */\r\n  newIndex(delta) {\r\n    return this.checkLoop(delta > 0 ? this.index - 1 : this.index + 1)\r\n  }\r\n\r\n  /**\r\n   * Returrns a new random index that is not the current one.\r\n   *\r\n   * @private\r\n   * @returns {Number} - The new index.\r\n   */\r\n  newRandomIndex() {\r\n    let randIndex\r\n\r\n    do {\r\n      randIndex = Math.floor(Math.random() * this.max)\r\n    } while (randIndex === this.index)\r\n\r\n    return randIndex\r\n  }\r\n\r\n  /**\r\n   * Gives a new index by checking if it needs to loop or not.\r\n   *\r\n   * @param {Number} index - The target index.\r\n   *\r\n   * @private\r\n   * @returns {Number} - The new index.\r\n   */\r\n  checkLoop(index) {\r\n    return index < 0 ? this.options.loop ? this.max - 1 : 0 : index > this.max - 1 ? this.options.loop ? 0 : this.max - 1 : index\r\n  }\r\n\r\n  /**\r\n   * Creates an object with data that will be given to user in their `callback` method.\r\n   *\r\n   * @param {Number} newIndex - The new index.\r\n   * @param {*} data - The custom data given by user in the `goTo` method.\r\n   *\r\n   * @private\r\n   * @returns {Object} - An object ready to be sent to user's `callback`.\r\n   */\r\n  createEvent(newIndex, data) {\r\n    let direction = newIndex > this.index ? 1 : -1\r\n\r\n    if (this.index === 0 && newIndex === this.max - 1) direction = -1\r\n    else if (this.index === this.max - 1 && newIndex === 0) direction = 1\r\n\r\n    return {\r\n      current: newIndex,\r\n      previous: this.index,\r\n      direction,\r\n      data,\r\n      done: this.done\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets a new index based on a targetted one.\r\n   *\r\n   * Calls user's `callback` with the correct data in its parameter.\r\n   *\r\n   * @param {Number} delta - The targetted index.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  callback(delta) {\r\n    if (this.isChanging()) return\r\n\r\n    const index = this.options.random ? this.newRandomIndex() : this.newIndex(delta)\r\n\r\n    if (index === this.index) {\r\n      this.changing = false\r\n\r\n      return\r\n    }\r\n\r\n    const event = this.createEvent(index)\r\n\r\n    if (this.options.auto) this.stop()\r\n\r\n    this.index = index\r\n    this.options.callback(event)\r\n  }\r\n}\r\n"],"names":["queue","id","ticking","tickId","opt","callback","this","max","bindMethods","defaults","el","loop","random","vertical","done","auto","interval","init","swipe","mouseSwipe","startAt","threshold","options","Object","assign","changing","length","children","index","isNaN","Math","min","intervalID","touch","startX","startY","endX","endY","diagonalMax","console","warn","intervalFn","bind","start","stop","touchStart","touchEnd","events","destroy","removeEventListener","getIndex","prev","goTo","next","data","isChanging","checkedIndex","checkLoop","event","createEvent","push","fn","lastTime","performance","now","tick","requestAnimationFrame","forEach","item","rafID","i","splice","cancelAnimationFrame","clearRafInterval","addEventListener","type","touches","screenX","screenY","changedTouches","handleSwipe","isGoingToX","isGoingToY","newIndex","delta","newRandomIndex","randIndex","floor","direction","current","previous"],"mappings":"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"}